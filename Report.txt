# Modern Declarative Programming
## A Swift Conclusion
///
	Declarative programming can be described as a pradigm, a style of building the structure and elements of computer programs, that expresses the logic of a computation without describing its control flow. Many languages applying this style attempt to minimize or eliminate side effects by describing what the program should accomplish in terms of the problem domain, rather than describing how to go about accomplishing it as a sequence of the programming language primitives. 
	
Several styles of programming, or forms of programming, exist that represent a declarative solution.
	- Constant programming: Relations between variables are stated in the form of constraints, specifying the properties of a solution to be found.
	- Domain Specific Languages: This is a computer language specialized to a particular application domain. This can take the form of either internal or external DSL's and therefor 		implemented with a wide variety of computing languages.
	- Functional programming: This attempts to minimize of eliminate side effects.
	- Hybrid languages: These specify dependencies in a declarative fashion, but include imperative lists of actions to take as well. 
	- Logic programming: The specifics of how queries are answered is up to the implementation and its theorm prover. It typically takes the form of some sort of unification.
	
	NOTE: Counter to declarative programming is imperative programming, where algorithms are implemented in terms of explicit steps. This is important to note as any declarative solution must avoid this implementation in their code for it to be truly declarative. 
	

### Introduction to Swift
	Swift is a new programming language for IOS and OS X introduced at Apples WWDC 2014 in June.. It was designed/created by Chris Lattner and has already been dubbed with many comparisons. Such as 'Objective-C without C' and 'Rusty Objective-C#++', it most certainly adopts the readability of Objective-C's named parameters and thr power of Objective-C's dynamic object model. Iy also provides seamless access to existing Cocoa frameworks and mix-and-match interoperability with Objective-C code.
	It is a Strongly typed language that adopts safe programming patterns and adds modern features to make programming easier, more flexible, and more fun. It is a industrial-quality systems programming language that is as expressive and enjoyable as a scripting language. Some important features that allow for the possibility of adapting a declarative programming style are the following:
	- Type inference & explicitly mutable/immutable variables
	- Generics
	- Operator Overloading
	- Classes/Reference Types (objects) & Value Types (structs, enums)
	- Tuples
	- Type extension
	- Optional Types
	- Pattern Matching
	
	
### Declaring the problem
	Looking at the different approaches to declarative programming, and the different uses it has, I decided to invest the time in looking into Domain Specific Languages (DSL's) and whether or not it was possible to write a DSL in swift using a declarative syntax. A DSL is a computer programming language of limited expressivness focused on a particular domain. In particular a DSL focuses 'limited expressivness', where a general purpose programming language provides lots of capabilities: supporting varied data, control, and abstraction structures. All of this is useful but makes it harder to learn and use. A DSL supports a bare minimum of features needed to support its domain. In otherwords, you can use DSL's to help build a system, or to give your system the definition of what you want the results to be, but not how you wish to gain these results.
	Reading through Martin Fowlers 'Domain Specific Languages' he gave a clear distinguishment of the difference between internal and external DSL's, and from this point onwards and reference to DSL's (unless specified) will be to internal DSL's. Specifically a internal DSL is a particular way of using a general purpose language. A script in an internal DSL is valid code in its general purpose language, but only uses a subset of the languages features in a particular style to handle one small aspect of the overall system. The result should have the feel of a custom language, rather than its host langauge. It is with this concept in mind that we seek to write code in Swift to discover the limits of how we can create an internal DSL, or in otherwords, does swift allow for declarative programming, or enough declarative programming to gain a result similar to examples from other languages such as Ruby.
	Martin Fowler presents a strong example of a State Machine, and how this can be written with an internal DSL. To test the limits of declarative programming with Swift I have created a State Machine, although, with a different domain. 
	The task that I have set is to write a Domain Specific Language for the configuration of a State Machine. The domain of this state machine is the application of Time Sheets. This is a similar problem that Martin Flowler deals with, and the solution is present in the same manner as his in showing the process in making code, and syntax, as declarative as possible, and looking more like a custom syntax then the actual language we are programming with. Below is a state diagram representing the problem, and showing how this problem can be solved using a state machine in the first place!
	
	![alt text](https://github.com/JamesTMoss/StateMachine/blob/master/diagram)
	
	The below example is written with Java:
	''' java
	Event signOut = new Event("SGNOUT");
	Event signIn = new Event("SGNIN");
	Event approve = new Event("APPRV");
	
	Command flag = new Command("FLAG");
	Command record = new Command("RCRD");
	Command adjustTimeStamp = new Command("ADJTS");
	Command finalize = new Command("FNLZ");
	
	State signedIn = new State("Signed In");
	State signedOut = new State("Signed Out");
	State pendingApproval = new State("Pending Approval");
	
	StateMachine machine = new StateMachine(signedOut);
	signedOut.addTransition(signIn, signedIn);
	signedOut.addAction(record);
	signedOut.addAction(adjustTimeStamp);
	signedIn.addTransition(signOut, pendingApproval);
	signedIn.addAction(record);
	signedIn.addAction(flag);
	signedIn.addAction(adjustTimeStamp);
	pendingApproval.addTransition(approve, signedOut);
	pendingApproval.addAction(finalize);
	'''
	
	This does not really represent a Declarative State Machine DSL, in fact it is hard to tell it is a state machine. JRuby Allows for a more readable looking state machine. It also is far more declarative then pure java.
	''' ruby
	event :signOut, "SGNOUT"
	event :signIn, "SGNIN"
	event :approve, "APPRV"
	
	command :flag, "FLAG"
	command :record, "RCRD"
	command :adjustTimeStamp, "ADJTS"
	command :finalize, "FNLZ"
	
	state :signedIn do
		actions :record, :adjustTimeStamp, :flag
		transitions :signOut -> :pendingApproval
	end
	
	state :signedOut do
		actions :record, :adjustTimeStamp
		transitions :signIn -> :signedIn
	end
	
	state :pendingApproval do
		actions :finalize
		transitions :approve -> :signedOut
	end
	'''
	
	So we have something here we like the looks of. It is simple, readable, and is of limited expressivness. This is a DSL based on a time sheet state machine.
	
### A Swift Solution
	Now that we have seen one other version of how this code can be implemented, in quite a declarative way with limited expressiveness and high readability, let's see if we can create something similar with Swift. Again the problem domain is a DSL representing the configuration of a State Machine.
	There are a few ways to approach this solution, the easiest is with simple object method calls, which will turn out something like the original java code above. This is what I began with to create a base from which I could begin to remove as many side effects and limit its expressivness to the point of either a similar solution that JRuby can achieve, or perhaps even further.
	
	''' swift
	let arrive, depart, approve: Event
	let record, finalise, flag, adjustTimeStamp: TimeSheetActions
	let signedIn, signedOut, pendingApproval: State
	let stateMachine: StateMachine
	    
	init() {
		arrive =  Event()           ; depart          = Event()
		approve = Event()
		record = TimeSheetActions() ; finalize        = TimeSheetActions() 
	    flag   = TimeSheetActions() ; adjustTimeStamp = TimeSheetActions()
	 
	 	signedIn    	= State(actions: [record, flag, adjustTimeStamp])
	 	signedOut   	= State(actions: [record, adjustTimeStamp])
		pendingApproval = State(actions: [finalize])
	 	let signOn      = Transition(event: arrive,  state: signedIn)
	 	let signOff     = Transition(event: depart,  state: pendingApproval)
		let approval 	= Transition(event: approve, state: signedOut)
	 	signedIn.addTransition(signOff)
	 	signedOut.addTransition(signOn)
		pendingApproval.addTransition(approval)
	 	
		stateMachine = StateMachine(states: [signedIn, signedOut, pendingApproval])
	 	stateMachine.currentState = signedOut
	 }
	 '''
	 
	 This looks a little better than the java code, but it still is'nt enough, it still does not look like a state machine. Each of the objects need to be declared and instantiated, which is not a very declarative at all. In this solution each of the states are instantiated with a set of actions that it can perform. Then the transitions are declared and intantiated using the events and states previously instantiated. Then these transitions are added to the states, with the states finally being added into the state machine, while also setting the initial state for it to start in. To try and create a more declarative solution we must try to remove the object declarations. 
	 I decided to pursue the use of enumurations, and see how easily Swift allows you to implement them, and how powerful they are within this language. One of the reasons for choosing this method is that you can very easily set predefined values and constants using them. With Swift what this allows is to pass in types of enums given a set of value Types (ie. String, Int, enum) and distinguish them from any other set of values. In the instance below you can see the enum 'Config' and how it has set up the particualar value types for each case.
	 
	 ''' swift
	 enum Config {
	     case Transition(Config, Config, Config)
	     case State(String, Config)
	     case Event(String)
	     case Actions([String])
	 }
	 
	 let stateMachine: StateMachine
	 init() {
	     stateMachine = StateMachine(StateMachineConfiguration: [
	             Config.Transition(Config.State("signedIn",        Config.Actions(["record", "flag", "adjustTimeStamp"])),
	                               Config.State("pendingApproval", Config.Actions(["finalise"])),
	                               Config.Event("signOut")),
	             Config.Transition(Config.State("signedOut",       Config.Actions(["record", "finalise", "adjustTimeStamp"])),
	                               Config.State("signedIn",        Config.Actions([])),
	                               Config.Event("signIn")),
	             Config.Transition(Config.State("pendingApproval", Config.Actions([])),
	                               Config.State("signedOut",       Config.Actions([])),
	                               Config.Event("approve"))
		])
	 }
	 '''

	 This use of enums have allowed us to create what looks like a custom syntax for configuration code. As you can see it is very readable, and looks much more like a DSL. However this is only the front end of the DSL, this is the language we have created to allow for very easy instantiation of a StateMachine. Below is some of the code that reads in the information passed into the StateMachine, and uses the enum to instantiate and create the actual objects from simple user input data.
	 
	 ''' swift
	 init(StateMachineConfiguration: [Config]) {
	        for transition in StateMachineConfiguration {
	             switch transition{
	             case .Transition(let startState, let endState, let event):
	                 var startName, endName, eventName: String
	                 switch startState{
	                 case .State(let stateName, let Actions):
	                     self.addState(startState)
	                     startName = stateName
	                 }
	                 switch endState{
	                 case .State(let stateName, let Actions):
	                     self.addState(endState)
	                     endName = stateName
	                 }
                
	                 switch event {
	                 case .Event(let eventID):
	                     var newEvent = true
	                     eventName = eventID
	                     for e in events { if eventID == e.IDcode { newEvent = false} }
	                     if newEvent {
	                         events.append(Event(IDcode: eventID))
	                     }
	                 }
	                 self.getState(startName)!.setTransition(self.getEvent(eventName)!, state: self.getState(endName)!)
	             }
	         }
	     }
	 '''
	 
	 In the above code you can see how the use of the enums has allowed us to seperate easily the information provided in the initial configuration and then instantiate the objects. This particular block of code also checks to see if any repeat data has been put in so it does not create multiples of the objects. This method of using the enums has allowed us to write a custom syntax for our DSL, and a 'fake' parsing of the data to generate the code. For both users and programmers it is easy to read the syntax, and write in it, with very little side effects present. So this final solution feels far more declarative then our original swift attempt.
	 
	 
### Conclusion



### Footnotes